# Java

## 数组

* 动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行

````java
String names[];
names = new String[3];
names[0] = “钱学森”;
names[1] = “邓稼先”;
names[2] = “袁隆平”;
````

* 静态初始化：在定义数组的同时就为数组元素分配空间并赋值。

````java
int arr1[] = new int[]{ 3, 9, 8};
int[] arr2 = {3,9,8};
````

数组是引用对象，new出来的数组存放在堆中

![image-20211018111936268](https://cdn.jsdelivr.net/gh/oyw6719119/gitbookpig/202110181119602.png)

## 面向对象

|              | 成员变量                         | 局部变量                                 |
| ------------ | -------------------------------- | ---------------------------------------- |
| 声明的位置   | 直接声明在类中                   | 方法形参或内部、代码块内、构造器内       |
| 修饰符       | private、public、static、final等 | 不能用权限修饰符修饰，可以用final修饰    |
| 初始化值     | 有默认初始化值                   | 没有默认初始化值，必须显式赋值，方可使用 |
| 内存加载位置 | 堆空间或静态域内                 | 栈空间                                   |

JavaSE 5.0 中提供了**Varargs(**variable number of arguments**)**机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。

````java
//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);
//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String…books);
````

**说明：**

1. 声明格式：方法名(参数的类型名 ...参数名)
2. 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
3. 可变个数形参的方法与同名的方法之间，彼此构成重载
4. 可变参数方法的使用与方法参数部分使用数组是一致的
5. 方法的参数部分有可变形参，需要放在形参声明的**最后**
6. 在一个方法的形参位置，最多只能声明**一个**可变个数形参

为什么java引用类型传的是地址？

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| 缺省      | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |

类的属性赋值

* 赋值的位置：

  ① 默认初始化

  ② 显式初始化

  ③ 构造器中初始化

  ④ 通过“对象.属性“或“对象.方法”的方式赋值

* 赋值的先后顺序：

  ① - ② - ③ - ④

### 继承

#### 类方法的重写：  

1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
2. 子类重写的方法的返回值类型**不能大于**父类被重写的方法的返回值类型
3. 子类重写的方法使用的访问权限**不能小于**父类被重写的方法的访问权限
* 子类不能重写父类中声明为private权限的方法
4. 子类方法抛出的异常**不能大于**父类被重写方法的异常

**注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为**

**static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。**

#### super

* 子类中所有的构造器默认都会访问父类中空参数的构造器 
* 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的
  构造器。同时，只能”二选一”，且必须放在构造器的首行
* 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错

| NO.  | 区别点     | this                                                   | super                                    |
| ---- | ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 1    | 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 直接访问父类中的属性                     |
| 2    | 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 直接访问父类中的方法                     |
| 3    | 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |

#### Object 类

````java
public void test() {
	char[] arr = new char[] { 'a', 'b', 'c' };
	System.out.println(arr);//
	int[] arr1 = new int[] { 1, 2, 3 };
	System.out.println(arr1);//
	double[] arr2 = new double[] { 1.1, 2.2, 3.3 };
	System.out.println(arr2);//
}
````

#### 包装类

````java
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);//
//比较上下两个结果
Object o2;
if (true)
	o2 = new Integer(1);
else
	o2 = new Double(2.0);
System.out.println(o2);//
````

````java
public void method1() {
  Integer i = new Integer(1);
  Integer j = new Integer(1);
  System.out.println(i == j);
  Integer m = 1;
  Integer n = 1;
  System.out.println(m == n);//
  Integer x = 128;
  Integer y = 128;
  System.out.println(x == y);//
}
````

